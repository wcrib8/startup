# CS 260 Notes

[My startup - Simon](https://simon.cs260.click)

## Helpful links

- [Course instruction](https://github.com/webprogramming260)
- [Canvas](https://byu.instructure.com)
- [MDN](https://developer.mozilla.org)

## Wolf Notes

assignment 1 - github: I learned a lot about repositories, using git and github, and how useful it will be for my startup. Excited to be able to build my own projects and share them here.

## Learning Notes

### Amazon Web Services AWS - EC2

web server - another computer that can be constantly running, allows web applications to be up 24/7. connects through IP address, which a domain will change to a url. The same could be done with a laptop, but would require my laptop to always be available, have enough power to support millions of fans.
web server is located in a data center. 
key pair is a file that acts as a password for your AWS account. 
SSH is secure shell, lets you connect to your server. Caddy file is the configuration file for your web service gateway. 
Elastic IP address allows you to not change an IP address everytime a server is started up.

### HTTPS, TLS, web certificates

HTTPS is the secure version of HTTP, allows only endpoints, server and user, to access data. Seeing the console program traceroute, we know sometimes data passes through many computers to reach you, we don't want everyone to have our information. 

Data is encrypted using the TLS protocol, which works by having a shared secret to encrypt data. It goes through a complex negotiation process, a core piece of this exchange is web certificates. Web certificates help identify the domain name to the one represented in the URL. If no match, then a big warning is displayed.

Web certificates are generated by a third party, creates a key encryption. REsponsible for verifying the certificate owner owns the domain name.
Caddy uses lets encrypt to generate a web certificate, lets encrypt tells the requester to return specific digital response. when successful, issues a certificate. 

### HTML Structure

two major elements - structure and content to web app. 
- body, header, footer, main, section, aside, p, table, ol/ul, div, spam
Example:
```
<body>
  <p>Body</p>
  <header>
    <p>Header - <span>Span</span></p>
    <nav>
      Navigation
      <div>Div</div>
      <div>Div</div>
    </nav>
  </header>

  <main>
    <section>
      <p>Section</p>
      <ul>
        <li>List</li>
        <li>List</li>
        <li>List</li>
      </ul>
    </section>
    <section>
      <p>Section</p>
      <table>
        <tr>
          <th>Table</th>
          <th>Table</th>
          <th>Table</th>
        </tr>
        <tr>
          <td>table</td>
          <td>table</td>
          <td>table</td>
        </tr>
      </table>
    </section>
    <aside>
      <p>Aside</p>
    </aside>
  </main>

  <footer>
    <div>Footer - <span>Span</span></div>
  </footer>
</body>
```
### HTML Input Elements

HTML includes many ways to accept user data input. Form was the original essential method to change the application based on user input. With JavaScript that has become unnecessary, but form is sometimes still used.
inputs have many types, can be determined wtih the type attribute.
some attributes:
- name
- disabled
- value
- required

attributes like these can confirm input data is correct or valid. This will be used for startup to ensure that input is valid, such as in authentication, during login.

### HTML Media Elements

elements represent media:
- img
- audio
- video
- svg (contain code to render an animated image)
- canvas (contain code to render an animated image)

media tags take a URL as an attribute. There is full path for URLs and relative path, helps to avoid adjusting all external page references.

adding an image code:
```<img alt="mountain landscape" src="https://images.pexels.com/photos/164170/pexels-photo-164170.jpeg" />```

audio code:
```<audio controls src="testAudio.mp3"></audio>```

video code:
``` <video controls width="300" crossorigin="anonymous">  <source src="https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4" /></video> ```

svg and canva allow you to create images within html. 


### CSS Frameworks

As web developers built more web apps, similar patterns were put into open source code, making it available to everyone and speeding up time for web development. Many frameworks exist today, all have similar functionality, but add something different.

Bootstrap is the most widely used framework. To use Bootstrap, a link to the package needs to be included in the head of html, giving access to bootstrap.

### Javascript - Arrays

arrays work very similar to lists, there are many functions and commands that can be used with arrays. Sample syntax:
```
function testAll(input, tester) {
  return input.every(tester);
}

const result = testAll(["abc", "bbbbb"], (i) => i.length > 3);

console.log(result);
```

### Javascript - Document Object Model (DOM)

For everything in html there is a node, every title word whitespace all is connected to a node. They all comprise of a tree, all underneath the html root node. Nodes can be accessed by the parent node. if adding children, they must be fst be created on the DOM, then inserted to the parent by appending:
```
function insertChild(parentSelector, text) {
  const newChild = document.createElement('div');
  newChild.textContent = text;

  const parentElement = document.querySelector(parentSelector);
  parentElement.appendChild(newChild);
}

insertChild('#courses', 'new course');
```
to delete elements, call the removeChild function on the parent element.

The DOM also allows you to inject entire blocks of HTML into an element. The following code finds the first div element in the DOM and replaces all the HTML it contains:
```
const el = document.querySelector('div');
el.innerHTML = '<div class="injected"><b>Hello</b>!</div>';
```
injecting html with javascript is an easy way for hackers to find access. here is an example of how a hacker would get through an image element:
```
<img src="bogus.png" onerror="console.log('All your base are belong to us')" />
```
DOM elements can have a function that is called whenever an event occurs on an element. These are event listeners. Event listener called when clicked:
```
const submitDataEl = document.querySelector('#submitData');
submitDataEl.addEventListener('click', function (event) {
  console.log(event.type);
});
```

`log` will output to the console. CSS parameters can also be included in log.
timers will show how long a piece of code is executed, use `time` and `timeEnd` to wrap said code.
To see how many times a block of code is called use the `count` function.


### React - Reactivity

Three major components for reactivity: `props`, `state`, and `render`. 
how React works:
App: Top level component that manages the color state.
ColorDisplay: Displays the currently selected color.
ColorPicker: Displays the color and allows for the selection of a new color.

using a `React.useState` function makes a state variable, this is how the value of an object changes with a change of state.
ex: 
```
const [color, updateColor] = React.useState('#737AB0');
```

### React - Promises

promise execution states:
pending - Currently running asynchronously
fulfilled - Completed successfully
rejected - Failed to complete

`setTimeout` is a function that can be used to delay the execution of code. Example:
```
const delay = (msg, wait) => {
  setTimeout(() => {
    console.log(msg, wait);
  }, 1000 * wait);
};

new Promise((resolve, reject) => {
  // Code executing in the promise
  for (let i = 0; i < 3; i++) {
    delay('In promise', i);
  }
});

// Code executing after the promise
for (let i = 0; i < 3; i++) {
  delay('After promise', i);
}

// OUTPUT:
//   In promise 0
//   After promise 0
//   In promise 1
//   After promise 1
//   In promise 2
//   After promise 2
```
Another Promise code that flips a coin, after delay there is a fifty fifty chance:
```
const coinToss = new Promise((resolve, reject) => {
  setTimeout(() => {
    if (Math.random() > 0.5) {
      resolve('success');
    } else {
      reject('error');
    }
  }, 10000);
});
```
The promise object has three functions: then, catch, and finally. The then function is called if the promise is fulfilled, catch is called if the promise is rejected, and finally is always called after all the processing is completed.

adding a 10 percent chance of the coin falling off the table to our coin toss code:
```
const coinToss = new Promise((resolve, reject) => {
  setTimeout(() => {
    if (Math.random() > 0.1) {
      resolve(Math.random() > 0.5 ? 'heads' : 'tails');
    } else {
      reject('fell off table');
    }
  }, 10000);
});


coinToss
  .then((result) => console.log(`Coin toss result: ${result}`))
  .catch((err) => console.log(`Error: ${err}`))
  .finally(() => console.log('Toss completed'));

// OUTPUT:
//    Coin toss result: tails
//    Toss completed
```

### React - Async/Await

asynchronous functions are functions that allow a program to start a long term task without waiting for it to finish, it can run in the background and the rest of the application can continue to work.
Await waits for a fulfilled promise condition, or throws an exception. heres an async/await version of above coin flip code instead of then, catch, finally:
```
try {
  const result = await coinToss();
  console.log(`Toss result ${result}`);
} catch (err) {
  console.error(`Error: ${err}`);
} finally {
  console.log(`Toss completed`);
}
```
```
function cow() {
  return 'moo';
}
console.log(cow());
// OUTPUT: moo

async function cow() {
  return 'moo';
}
console.log(cow());
// OUTPUT: Promise {<fulfilled>: 'moo'}

async function cow() {
  return new Promise((resolve) => {
    resolve('moo');
  });
}
console.log(cow());
// OUTPUT: Promise {<pending>}
```
Async keyword means a function returns a promise. 

### Web Services - Fetch

HTTP requests have changed the Web from static HTML pages (Web 1.0) to one of web applications (Web 2.0) that interact with the user. Today fetch API is the preferred way to make HTTP requests. Fetch takes a URL and returns a promise. The promise `then` function asynchronously takes a callback function. 
The following example makes a fetch request to get and display an inspirational quote. If the request method is unspecified, it defaults to GET.
```
fetch('https://quote.cs260.click')
  .then((response) => response.json())
  .then((jsonResponse) => {
    console.log(jsonResponse);
  });
```
response:
```
{
  author: 'Kyle Simpson',
  quote: "There's nothing more permanent than a temporary hack."
}
```
To do a POST request you populate the options parameter with the HTTP method and headers.
```
fetch('https://jsonplaceholder.typicode.com/posts', {
  method: 'POST',
  body: JSON.stringify({
    title: 'test title',
    body: 'test body',
    userId: 1,
  }),
  headers: {
    'Content-type': 'application/json; charset=UTF-8',
  },
})
  .then((response) => response.json())
  .then((jsonResponse) => {
    console.log(jsonResponse);
  });
```

### Express 

Node Package `Express` provides support for:

Routing requests for service endpoints (Routing)
Manipulating HTTP requests with JSON body content (Handling JSON requests/responses)
Generating HTTP responses
Using `middleware` to add functionality
(also error handling)

You create an Express application by using NPM to install the Express package and then calling the `express` constructor to create the Express application and listen for HTTP requests on a desired port.
```
➜ npm install express

const express = require('express');
const app = express();

app.listen(8080);
```
With the `app` object you can now add HTTP routing and middleware functions to the application.

The callback function has three parameters that represent the HTTP request object (req), the HTTP response object (res), and the next routing function that Express expects to be called if this routing function wants another function to generate a response.

route function examples:
```
// Wildcard - matches /store/x and /star/y
app.put('/st*/:storeName', (req, res) => res.send({ update: req.params.storeName }));

// Pure regular expression
app.delete(/\/store\/(.+)/, (req, res) => res.send({ delete: req.params[0] }));
```

Middleware are functions that process requests in order before responses are sent. (built-in middleware, custom middleware, 3rd aprty middleware)
example of writing your own middleware:
```
app.use((req, res, next) => {
  console.log(req.originalUrl);
  next();
});
```

<img width="300" height="445" alt="image" src="https://github.com/user-attachments/assets/d54a4e41-8024-439e-b678-cc0905d4f8df" />

with npm you can use third party middleward

Error middleware has 4 parameters
```
app.use((err, req, res, next) => {
  res.status(500).send({ type: err.name, message: err.message });
});
```

### Data Services

Data services allow user data to be stored persistently. Mongo is very popular. 





## Startup Notes

### HTML

I learned a lot implementing HTML, learned all about the structure, including head and body, with the body including header, main, and footer. there are many different functions to display information, including `<p>` `<a>` `<table>` and many more. `<img width="" src="">` will display a picture, can also use `<a><href>` to add links.
I can use the live server extension to see the changes I've applied, and also use inspect to debug and see what different code is doing on my page. 
HTML builds the structure of the website, there is no interactivity, at least very limited, but makes a framework.

### CSS

I learned about the many functions and applications of CSS. these tools can be used to add font and style to text, change marigins, borders, and more. using frameworks allows you to access existing CSS content, such as bootstrapp and you can use their premade designs. I appreciate learning about flex, which helps to keep content within the window if it is resized, or rotated. to allow css to attach to the html, in the html code you need to add classes, which link to classes defined in css, pointing to set parameters for borders, fonts, colors, margins, or whatever is set in the class.

### React Phase 1

I learned about the efficiency of using React, being able to use routes and components so that html pages are kept to a minimum, can prepare for user interaction. Components are the main elements from my html pages. 

### React Phase 2

There is a lot going on with React. I think the most important things are useState and useEffect, these can apply values to elements and objects that let you manipulate what appears on the screen, like counters, or modals, or buttons responding and having an action. This makes users aactually able to interact with the application.

### Service

Service is tough, but it allows for user data to be saved in the backend, not just locally. Allows for certain data to be stored elsewhere, separate backend and frontend functions.

### Database

Next step to service, using a database allows for user data to persist, and for data to be shared globally. also makes it easier for users to continue to use and update service. Changes needed to be made to save data with respect to the database instead of locally and backend.

### WebSocket

Websockets allow for connection to other users. I made it so websocket connection is activated in app, so all pages can receive referrals. This is super useful to allow communication between users.



## Midterm Notes

### review #1

- In HTML, the <link> element is used to link external resources to your web page — most commonly, it links to external CSS stylesheets.
- How would you display an image with a hyperlink in HTML? answer:
  ```
  <a href="https://example.com">
  <img src="image.jpg" alt="Example image">
  </a>
  ```
  <a> defines anchor, or link, <img> defines the image
- a div tag groups elements together and divides the page into sections
- when applying styles, . or # is used to specify specific classes or ids. if just div is used instead of .div, then the elements inside of div apply to all divs in the html.
- #title targets one specific matching id attribute element `<h1 id="title">Welcome</h1>`
```
#title {
  color: blue;
  text-align: center;
}
```
  .grid targets any elements with matching `class` attribute:
```
<div class="grid">Grid 1</div>
<div class="grid">Grid 2</div>

.grid {
  display: grid;
  gap: 10px;
}
```
- `.style.color` accesses the CSS `color` property of that element
- $${\color{green}content}$$ -> $${\color{red}padding}$$ (space inside box, surrounding content, takes background color) -> $${\color{blue}border}$$(visible edge surrounding padding) -> $${\color{orange}margin}$$ (space outside box)
- `margin: 10px 20px 30px 40px;`, order: top, right, bottom, left
  `margin: 10px 20px 30px;`, top, left/right, bottom
  `margin: 10px 20px;`, top/bottom, left/right
  `margin: 10px;`, all sides
- showing arrow syntax for javascript
```
function multiply(a, b) {
  return a * b;
}

const multiply = (a, b) => a * b;

console.log(multiply(4, 5)); // Output: 20
```
- .map() applies a function to each element of an original array
```
const numbers = [2, 4, 6];
const doubled = numbers.map(num => num * 2);
console.log(doubled);
```
- ~getElementById("greetBtn") grabs the <button> element from the DOM.
  ~addEventListener("click", ...) listens for a click event.
  ~When clicked, it runs the arrow function, which logs "Hello, world!" to the console.
  
- ~The # in a selector in JS means “ID” (just like in CSS).
  ~document.querySelector("#mainTitle") looks through the DOM and returns the first element with that ID.
  ~Example HTML it would target:
  `<h1 id="mainTitle">Welcome!</h1>`

- <span> is an inline element by default. That means it does not start on a new line and only takes up as much width as its content.
- `getElementById` : selects a single element by its id. ids are meant to be unique, returns **one element**
- `querySelector` : selects the **first element** that matches a CSS selector:
  ```
  document.querySelector("#myId");  // by id
  document.querySelector(".myClass");  // by class
  document.querySelector("p");        // by tag
  ```
- html ordered (numbered) list tag: <ol> ;  html unordered (bulletted) list tag: <ul> ; html tag for first level heading: <h1>
- `<!DOCTYPE html>` tells the browser that the document is an HTML5 document.
- with switch syntax in JS, you need to add a break statement if you don't want later cases to also be outputted:
```
let grade = "B";

switch (grade) {
  case "A":
    console.log("Excellent");
  case "B":
    console.log("Good");
  case "C":
    console.log("Average");
  default:
    console.log("Needs Improvement");
}
```
  will output:
```
Good
Average
Needs Improvement
```
- correct JS syntax for making an object: `let person = { name: "Alice", age: 25 };`
- you can add properties to objects:
```
let person = { name: "Alice", age: 25 };

// Add a new property
person.city = "Provo";

console.log(person);
// Output: { name: "Alice", age: 25, city: "Provo" }
```
- If you want to include JavaScript on an HTML page, which tag do you use?   `<script>`
- JSON: (JavaScript Object Notation) A text-based format for storing and exchanging data. JSON is a lightweight, text-based data format that represents data as key-value pairs (similar to JavaScript objects). It is commonly used for sending data between a server and a client.
- terminal commands:
1 chmod

Purpose: Changes the permissions of a file or directory.

Example:

`chmod 755 script.sh`


Makes script.sh readable and executable by everyone, writable by the owner.

-----> ./ is the command to run the file, or sh : `./script.sh`

2️⃣ pwd

Purpose: Prints the current working directory.

Example:
```
pwd
# Output: /home/user/Documents
```
3️⃣ cd

Purpose: Changes the current directory.

Example:

`cd /home/user/Desktop`

4️⃣ ls

Purpose: Lists files and directories in the current directory.

Example:
```
ls
# Output: file1.txt  file2.txt  folder1
```
5️⃣ vim

Purpose: Opens the Vim text editor to edit files in the terminal.

Example:

`vim notes.txt`

6️⃣ nano

Purpose: Opens the Nano text editor, a simpler terminal editor.

Example:

`nano notes.txt`

7️⃣ mkdir

Purpose: Creates a new directory.

Example:

`mkdir new_folder`

8️⃣ mv

Purpose: Moves or renames files/directories.

Example:
```
mv oldname.txt newname.txt    # rename
mv file.txt /home/user/Desktop/  # move
```
9️⃣ rm

Purpose: Removes files or directories.

Example:
```
rm file.txt           # remove a file
rm -r old_folder/     # remove a directory recursively
```
1️⃣0️⃣ man

Purpose: Displays the manual/help page for a command.

Example:

`man ls`

1️⃣1️⃣ ssh

Purpose: Connects to a remote server via Secure Shell (SSH).

Example:

`ssh user@remote-server.com`

1️⃣2️⃣ ps

Purpose: Shows currently running processes.

Example:

`ps aux`

1️⃣3️⃣ wget

Purpose: Downloads files from the internet via command line.

Example:

`wget https://example.com/file.zip`

1️⃣4️⃣ sudo

Purpose: Runs a command as superuser (administrator).

Example:

`sudo apt update`

- Which of the following console command creates a remote shell session?    `ssh`
  ssh stands for Secure Shell. It allows you to log in to a remote server securely and execute commands as if you were on that machine.
- `ls` → lists files and directories.
  `-l` → long format: shows detailed information like permissions, owner, group, size, and modification date.
  `-a` → shows all files, including hidden files (those starting with a dot .).
  Combined as `ls -la`, it produces a detailed list of all files, including hidden ones.
- TLD: top-level domain
- given domain name: banana.fruit.bozo.click:
  Top-Level Domain (TLD): click → the last part of the domain.
  Root Domain (second-level domain): bozo → the main domain registered under the TLD.
  Subdomain: banana.fruit → any prefixes before the root domain.
- To enable HTTPS, a website must have a TLS/SSL certificate (commonly called a web certificate). web certificate = necessary for HTTPS
- An A record (Address record) maps a domain name directly to an IPv4 IP address. Example: `example.com → 192.0.2.1`
  An A record cannot point to another A record directly. If you want a domain to alias another domain, you use a CNAME (Canonical Name) record instead.
  Example of a CNAME:
  ```
  www.example.com → example.com
  example.com → 192.0.2.1  (A record)
  ```
- Port 80 → HTTP (HyperText Transfer Protocol)
  Port 443 → HTTPS (HTTP over TLS/SSL)
  Port 22 → SSH (Secure Shell)
- sample Promise code:
```
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Success!");
  }, 1000);
});

promise
  .then((message) => {
    console.log(message);
    return "Next step";
  })
  .then((nextMessage) => {
    console.log(nextMessage);
  })
  .catch((error) => {
    console.log("Error:", error);
  });
```
will output:
Success!
Next step

A Promise is created that resolves with "Success!" after 1 second.
`.then((message) => { ... })` runs when the Promise resolves, printing "Success!".
Returning  `"Next step"` from the first `.then` passes it to the next `.then` in the chain.
The second `.then` prints `"Next step"`.
`.catch` is not triggered because there is no error.

`.then` handles successful resolutions.
Returning a value inside a `.then` passes it to the next `.then`.
`.catch` only runs if the Promise rejects.


### review #2

example counter func onclick
```
document.getElementById("plus").onclick = () => {
    count++
    number.textContent = count
```

example html setup with JS file initialized:
```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title> Click Counter</title>
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <form type="click" id="counterForm">
            <p id="number">0</p>
            <button type="button" id="plus">+</button>
            <button type="button" id="minus">-</button>
            <button type="button" id="minus5">-5</button>
            <button type="button" id="plus5">+5</button>
        </form>

        <script src="counter.js"></script>
    </body>
</html>
```

example CSS
```
body{
  font-family: Arial;
  padding:20px;
  background-color: grey;
}
#message{
  font-weight: bold;
}
```

Examle event listener code
```
const colors = document.getElementById('background')

colors.addEventListener('change', () =>{
    const color = colors.value;
    console.log(color)
    
    document.body.style.background = color;
    document.body.style.color = 'yellow'
})
```




## Final Notes

1. default port for http/https/ssh - http: port 80, https: port 443, ssh: port 22
2. what does an httpstatus code in the range of 300/400/500 indicate?
  - 300-399 (3xx - Redirection): The requested resource has been moved or the client needs to take additional action to complete the request. Common examples           include 301 (Moved Permanently), 302 (Found/Temporary Redirect), and 304 (Not Modified).
  - 400-499 (4xx - Client Errors): There's an error with the client's request. The client did something wrong, like requesting a page that doesn't exist or             lacking proper authentication. Common examples include 400 (Bad Request), 401 (Unauthorized), 403 (Forbidden), and 404 (Not Found).
  - 500-599 (5xx - Server Errors): The server encountered an error and couldn't fulfill a valid request. Something went wrong on the server side. Common examples       include 500 (Internal Server Error), 502 (Bad Gateway), and 503 (Service Unavailable).

3. http header content type:
  a) specifies media type, allowing you to **indicate format** of (html, json, images, etc), enable proper **parsing**, and **specify character encoding**               (charset info)
  b) Common examples:
        text/html - HTML documents
        application/json - JSON data
        application/xml - XML data
        text/plain - Plain text
        image/jpeg - JPEG images
        multipart/form-data - Form submissions with file uploads
        application/x-www-form-urlencoded - Standard form submissions

4.   Secure Cookie: A cookie with the Secure attribute is only sent to the server with an encrypted request over the HTTPS protocol, never with unsecured HTTP                         mozilla (except on localhost). This helps protect against man-in-the-middle attacks by ensuring the cookie can't be intercepted over                               unencrypted connections.
                    example: `Set-Cookie: id=a3fWa; Secure`
    HttpOnly Cookie: A cookie with the HttpOnly attribute can't be accessed by JavaScript mozilla, for example using Document.cookie. It can only be accessed when                       it reaches the server. This is particularly important for session cookies, as it helps mitigate cross-site scripting (XSS) attacks mozilla.
                    example: `Set-Cookie: id=a3fWa; HttpOnly`
    SameSite Cookie: The SameSite attribute lets servers specify whether/when cookies are sent with cross-site requests mozilla, helping prevent information                             leakage and providing protection against cross-site request forgery (CSRF) attacks. It has three possible values:
                      Strict: The browser only sends the cookie with requests originating from the cookie's origin site (useful for authentication)
                      Lax: Similar to Strict, but the browser also sends the cookie when the user navigates to the cookie's origin site from a different site
                      None: Cookies are sent on both originating and cross-site requests (requires Secure attribute)
                       example: ``` Set-Cookie: cart=110045; SameSite=Strict
                                    Set-Cookie: affiliate=e4rt45dw; SameSite=Lax
                                    Set-Cookie: widget_session=7yjgj57e4n3d; SameSite=None; Secure  ```

5. example of express middleware console.log output for GET request with url path of /api/document:
```
const express = require('express');
const app = express();

// Middleware 1: Logs all requests
app.use((req, res, next) => {
  console.log('Method:', req.method);
  console.log('Path:', req.path);
  next();
});

// Middleware 2: Specific to /api routes
app.use('/api', (req, res, next) => {
  console.log('API route accessed');
  next();
});

// Middleware 3: Route handler
app.get('/api/document', (req, res) => {
  console.log('Document route handler');
  res.send('Document data');
});

app.listen(3000);
``

**For a GET request to `/api/document`, the console output would be:**
``
Method: GET
Path: /api/document
API route accessed
Document route handler
```

  middleware path: Client Request → Middleware 1 → Middleware 2 → Middleware 3 → Route Handler → Response to Client

6. express servic code fetch return:
```
const express = require('express');
const app = express();

app.use(express.json());

// Endpoint 1: Get user data
app.get('/api/user/:id', (req, res) => {
  const userId = req.params.id;
  res.json({
    id: userId,
    name: 'John Doe',
    email: 'john@example.com'
  });
});

// Endpoint 2: Create a new post
app.post('/api/posts', (req, res) => {
  const { title, content } = req.body;
  res.status(201).json({
    success: true,
    post: {
      id: 123,
      title: title,
      content: content,
      createdAt: new Date()
    }
  });
});

// Endpoint 3: Delete a comment
app.delete('/api/comments/:id', (req, res) => {
  res.json({
    success: true,
    message: 'Comment deleted'
  });
});

app.listen(3000);
```
```
fetch('http://localhost:3000/api/user/42')
  .then(response => response.json())
  .then(data => console.log(data));
```
returns:
```
{
  id: '42',
  name: 'John Doe',
  email: 'john@example.com'
}
```
```
fetch('http://localhost:3000/api/posts', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    title: 'My First Post',
    content: 'This is the content'
  })
})
  .then(response => response.json())
  .then(data => console.log(data));
```
returns:
```
{
  success: true,
  post: {
    id: 123,
    title: 'My First Post',
    content: 'This is the content',
    createdAt: '2024-12-11T10:30:00.000Z' // Current timestamp
  }
}
```
```
fetch('http://localhost:3000/api/comments/99', {
  method: 'DELETE'
})
  .then(response => response.json())
  .then(data => console.log(data));
```
returns:
```
{
  success: true,
  message: 'Comment deleted'
}
```

7. given a list of users or ids, a query can be used to request a specific data type. findOne will return the first. find or collection.find will return all.
8. how should user passwords be stored? - NEVER store as plain text, always hash before storing in a database. common way is using bcrypt.
          - encryption is two-way (can be decrypted), DON'T USE ENCRYPTION
          - Hashing is one-way (cannot be reversed) , use this
9. websocket code example:
```
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 9900 });

wss.on('connection', (ws) => {
  console.log('Client connected');
  
  // Send a welcome message when client connects
  ws.send('Welcome to the server!');
  
  // Listen for messages from the client
  ws.on('message', (message) => {
    console.log('Received from client:', message);
    
    // Echo the message back with a prefix
    ws.send(`Server received: ${message}`);
  });
  
  // Send a message after 2 seconds
  setTimeout(() => {
    ws.send('Hello from server after 2 seconds');
  }, 2000);
});

console.log('WebSocket server running on port 9900');
```
```
const socket = new WebSocket('ws://localhost:9900');

socket.onopen = () => {
  console.log('Connected to server');
  socket.send('Hello from client!');
};

socket.onmessage = (event) => {
  console.log('Message from server:', event.data);
};

socket.onclose = () => {
  console.log('Disconnected from server');
};

socket.onerror = (error) => {
  console.log('WebSocket error:', error);
};
```
---

## **What Will the Frontend Log to the Console?**
```
Connected to server
Message from server: Welcome to the server!
Message from server: Server received: Hello from client!
Message from server: Hello from server after 2 seconds
```

---

## **Explanation of the Flow:**

1. **Connection established**
   - Frontend: `socket.onopen` fires → logs "Connected to server"
   - Frontend: Sends "Hello from client!" to server

2. **Server sends welcome message**
   - Backend: Sends "Welcome to the server!"
   - Frontend: `socket.onmessage` fires → logs "Message from server: Welcome to the server!"

3. **Server receives and echoes client message**
   - Backend: Receives "Hello from client!" and sends back "Server received: Hello from client!"
   - Frontend: `socket.onmessage` fires → logs "Message from server: Server received: Hello from client!"

4. **Server sends delayed message**
   - Backend: After 2 seconds, sends "Hello from server after 2 seconds"
   - Frontend: `socket.onmessage` fires → logs "Message from server: Hello from server after 2 seconds"

---

## **What the Backend Logs to the Console:**
```
WebSocket server running on port 9900
Client connected
Received from client: Hello from client!
```

10. what is websocket protocol intended to provide? 
    Key Features WebSocket Provides:
    1. Full-Duplex Communication
    
    Both client and server can send messages simultaneously and independently
    No need to wait for a request before sending a response
    True two-way communication channel
    
    2. Real-Time Data Transfer
    
    Low latency message delivery
    Instant updates without polling
    Perfect for applications that need immediate data sync
    
    3. Persistent Connection
    
    Connection stays open after the initial handshake
    No need to repeatedly establish new connections
    Reduces overhead compared to HTTP requests
    
    4. Efficient Communication
    
    Minimal overhead per message (just a few bytes)
    No HTTP headers sent with each message after initial handshake
    Less bandwidth usage compared to HTTP polling

    Two-way: Either side can send anytime
    Efficient: Minimal frame overhead
    Real-time: Instant message delivery

11. what do the acronyms stand for?
      a) JSX = JavaScript XML  (React, html like code within JS)
      b) JS = JavaScript (Node.js, for web development)
      c) AWS = Amazon Web Services (cloud computing platform)
      d) NPM = Node Package Manager (Node.js, JavaScript, package manager for JavaScript)
      e) NVM = Node Version Manager (manage Node.js versions)

12. Html document with react component
```
function UserProfile(props) {
  return (
    <div>
      <h1>Welcome, {props.name}!</h1>
      <p>Age: {props.age}</p>
      <p>Status: {props.isActive ? 'Active' : 'Inactive'}</p>
    </div>
  );
}

function App() {
  return (
    <div>
      <UserProfile name="Sarah" age={28} isActive={true} />
      <UserProfile name="John" age={35} isActive={false} />
    </div>
  );
}

// Render to the page
ReactDOM.render(<App />, document.body);
```

---

## **What Text Content Will Be Generated?**
```
Welcome, Sarah!
Age: 28
Status: Active

Welcome, John!
Age: 35
Status: Inactive
```

13. given react components, what will be generated?
```
function Header(props) {
  return <h1>{props.title}</h1>;
}

function UserInfo(props) {
  return (
    <div>
      <p>Name: {props.name}</p>
      <p>Email: {props.email}</p>
    </div>
  );
}

function Card(props) {
  return (
    <div className="card">
      <Header title={props.heading} />
      <UserInfo name={props.userName} email={props.userEmail} />
      <p>Member since: {props.year}</p>
    </div>
  );
}

function App() {
  return (
    <div>
      <Header title="User Dashboard" />
      <Card 
        heading="Profile" 
        userName="Alice Johnson" 
        userEmail="alice@example.com" 
        year="2020" 
      />
      <Card 
        heading="Settings" 
        userName="Bob Smith" 
        userEmail="bob@example.com" 
        year="2021" 
      />
    </div>
  );
}

ReactDOM.render(<App />, document.body);
```

---

## **What Text Content Will Be Generated?**
```
User Dashboard

Profile
Name: Alice Johnson
Email: alice@example.com
Member since: 2020

Settings
Name: Bob Smith
Email: bob@example.com
Member since: 2021
```

14. what does react component with useState do?
    `React.useState` is a React Hook that allows you to add state to functional components. State is data that can change over time, and when it changes, React         automatically re-renders the component to reflect the new data.
      you can add changable data, store persisting values, trigger re-renders, create interactive user interfaces.
      with useState, components are dynamic and interactive

15. React hooks - allow us to use state and other React features. includes useState, useEffect, useContext, etc.
16. a) State Hooks: State lets a component "remember" information like user input
        ```
        function ImageGallery() {
          const [index, setIndex] = useState(0);
          // Component remembers which image is selected
        }
        ```
    b) Context Hooks: Context lets a component receive information from distant parents without passing it as props react. For example, your app's top-level             component can pass the current UI theme to all components below, no matter how deep.
        ```
        function Button() {
          const theme = useContext(ThemeContext);
          // Can access theme without prop drilling
        }
        ```
    c) Ref Hooks: Refs let a component hold some information that isn't used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref           does not re-render your component react. Refs are an "escape hatch" from the React paradigm, useful when you need to work with non-React systems, such as         the built-in browser APIs.
        ```
        function Form() {
          const inputRef = useRef(null);
          // Can directly access the input DOM element
        }
        ```
    d) Effect Hooks: Effects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations,               widgets written using a different UI library, and other non-React code
        ```
        function ChatRoom({ roomId }) {
          useEffect(() => {
            const connection = createConnection(roomId);
            connection.connect();
            return () => connection.disconnect();
          }, [roomId]);
          // Connects to external chat system
        }
        ```
    e) Performance Hooks: A common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached               calculation or to skip a re-render if the data has not changed since the previous render
        ```
        function TodoList({ todos, tab, theme }) {
          const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);
          // Caches the filtered result
        }
        ```

17. React routes, uses client side navigation to avoid full page reloads. Routers help with navigation.
18. The package.json file is the manifest/configuration file for Node.js projects. It contains metadata about your project and manages your project's                 dependencies, scripts, and configuration.
    - project metadata - stores basic info about project
    - dependency management - lists packages/libraries project needs
    - scripts - defines commands that can be run with `npm run`
    - entry point - specifies main file of application
    when you run `npm install` npm reads package.json and installs all listed dependencies into the node_modules folder.

    also creates `package-lock.json` which locks exact versions of dependencies, ensures consistent installs, committed to version control
    package.json helps with reproducing builds, collaboration, automation, documentation, and publishing

    package.json is the configuration file that defines your Node.js project, manages its dependencies, and provides scripts for common tasks.

19. The fetch() function is a built-in JavaScript API used to make HTTP requests to servers. It allows you to retrieve (or send) data from/to a URL, such as           fetching data from an API, submitting forms, or uploading files.
      ```
      fetch('https://api.example.com/users')
        .then(response => response.json())  // Parse JSON from response
        .then(data => {
          console.log(data);  // Use the data
        })
        .catch(error => {
          console.error('Error fetching data:', error);
        });
      ```
      - Make HTTP requests to APIs
      - Retrieve data from servers (GET)
      - Send data to servers (POST, PUT, DELETE)
      - Handle responses asynchronously with Promises
      - Work with JSON, text, blobs, and other data formats
   
20. Node.js is a JavaScript runtime environment that allows you to run JavaScript code outside of a web browser, primarily on servers. It enables developers to       use JavaScript for backend/server-side programming, not just frontend web pages.
    key concept - javascript everywhere. same language for frontend and backend.
    Node.js does:
      1. runs javascript on the server
      2. handles file system operations - read and write files
      3. build APIs that handle HTTP requests
      4. connects to databases
      5. handles real time communication - websockets
      6. runs build tools and scripts

     handles asynchronous operations


21. PM2 (Process Manager 2) is a production process manager for Node.js applications. It keeps your Node.js applications running continuously, restarts them if       they crash, and provides monitoring and management tools.

    PM2 ensures your Node.js application stays alive in production by:

    Automatically restarting crashed applications
    Running applications in the background (as a daemon)
    Managing multiple applications
    Load balancing across CPU cores
    Monitoring performance and logs

    instead of running `node app.js`, use PM2: `pm2 start app.js`
    What happens:
      App runs in the background
      You can close the terminal and the app keeps running
      PM2 assigns it an ID and name

    PM2 is used to:
      ✅ Keep Node.js apps running 24/7
      ✅ Automatically restart crashed applications
      ✅ Run apps in the background (daemon mode)
      ✅ Load balance across multiple CPU cores
      ✅ Monitor performance (CPU, memory, logs)
      ✅ Manage multiple applications
      ✅ Auto-start applications on server reboot
      ✅ Zero-downtime deployments

22. What Vite Does
    1. Lightning-Fast Development Server
    2. Instant Hot Module Replacement (HMR) - When you save a file, changes appear in the browser instantly without full page reload:
    3. Builds Optimized Production Bundles `npm run build`
   
     Vite is a next-generation frontend build tool that provides an extremely fast development experience with instant server startup and hot module replacement,       while creating optimized production builds.
    
    
    







## Class Notes

<img src="https://github.com/user-attachments/assets/6e4898a9-191b-41aa-88d7-9a1d0b72de1f" width="400"/>

<img src="https://github.com/user-attachments/assets/6c30e360-4788-4828-a80a-ab3101a6184d" width="400"/>

<img src="https://github.com/user-attachments/assets/82a72a21-50da-4c6b-a680-7f21c2008ea2" width="400"/>






# Example repo

## AWS

My IP address is: 54.81.96.130
Launching my AMI I initially put it on a private subnet. Even though it had a public IP address and the security group was right, I wasn't able to connect to it.

## Caddy

No problems worked just like it said in the [instruction](https://github.com/webprogramming260/.github/blob/main/profile/webServers/https/https.md).

## HTML

This was easy. I was careful to use the correct structural elements such as header, footer, main, nav, and form. The links between the three views work great using the `a` element.

The part I didn't like was the duplication of the header and footer code. This is messy, but it will get cleaned up when I get to React.

## CSS

This took a couple hours to get it how I wanted. It was important to make it responsive and Bootstrap helped with that. It looks great on all kinds of screen sizes.

Bootstrap seems a bit like magic. It styles things nicely, but is very opinionated. You either do, or you do not. There doesn't seem to be much in between.

I did like the navbar it made it super easy to build a responsive header.

```html
      <nav class="navbar navbar-expand-lg bg-body-tertiary">
        <div class="container-fluid">
          <a class="navbar-brand">
            <img src="logo.svg" width="30" height="30" class="d-inline-block align-top" alt="" />
            Calmer
          </a>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent">
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
              <li class="nav-item">
                <a class="nav-link active" href="play.html">Play</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="about.html">About</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="index.html">Logout</a>
              </li>
            </ul>
          </div>
        </div>
      </nav>
    </header>
```

I also used SVG to make the icon and logo for the app. This turned out to be a piece of cake.

```html
<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
  <rect width="100" height="100" fill="#0066aa" rx="10" ry="10" />
  <text x="50%" y="50%" dominant-baseline="central" text-anchor="middle" font-size="72" font-family="Arial" fill="white">C</text>
</svg>
```

## React Part 1: Routing

Setting up Vite and React was pretty simple. I had a bit of trouble because of conflicting CSS. This isn't as straight forward as you would find with Svelte or Vue, but I made it work in the end. If there was a ton of CSS it would be a real problem. It sure was nice to have the code structured in a more usable way.

## React Part 2: Reactivity

This was a lot of fun to see it all come together. I had to keep remembering to use React state instead of just manipulating the DOM directly.

Handling the toggling of the checkboxes was particularly interesting.

```jsx
<div className="input-group sound-button-container">
  {calmSoundTypes.map((sound, index) => (
    <div key={index} className="form-check form-switch">
      <input
        className="form-check-input"
        type="checkbox"
        value={sound}
        id={sound}
        onChange={() => togglePlay(sound)}
        checked={selectedSounds.includes(sound)}
      ></input>
      <label className="form-check-label" htmlFor={sound}>
        {sound}
      </label>
    </div>
  ))}
</div>
```
